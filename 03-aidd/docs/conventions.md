# Правила разработки кода для кулинарного помощника

## Введение

Этот документ содержит правила разработки для code-ассистента, основанные на принципах проекта из [`vision.md`](docs/vision.md). Правила следуют принципам **KISS**, **YAGNI** и **минимализма**.

## Стиль кода

### Именование
- **Переменные**: `snake_case`, описательные и понятные
  ```python
  # Хорошо
  bot_token = "your_token"
  user_message = "Как приготовить пасту?"
  
  # Плохо
  bt = "your_token"
  msg = "Как приготовить пасту?"
  ```

- **Функции**: `snake_case`, глаголы, описывающие действие
  ```python
  # Хорошо
  def load_config():
  def send_message_to_user():
  
  # Плохо
  def config():
  def msg():
  ```

- **Классы**: `PascalCase`, существительные
  ```python
  # Хорошо
  class TelegramBot:
  class LLMClient:
  
  # Плохо
  class telegram_bot:
  class llm_client:
  ```

### Форматирование
- **Отступы**: 4 пробела
- **Длина строки**: максимум 88 символов
- **Пустые строки**: 1 строка между функциями, 2 строки между классами

### Комментарии
- Комментируйте любую логику
- Избегайте очевидных комментариев
- Используйте docstrings для публичных функций

```python
def process_cooking_question(message: str) -> str:
    """Обрабатывает кулинарный вопрос пользователя.
    
    Args:
        message: Текст сообщения от пользователя
        
    Returns:
        Ответ кулинарного помощника
    """
    # Сложная логика обработки требует комментария
    if "заменить" in message.lower():
        # Поиск ингредиентов для замены
        pass
```

## Архитектурные принципы

### Структура проекта
- **Минимальное количество файлов**: 2-3 основных файла
- **Основные компоненты**:
  - [`bot.py`](src/bot.py) - обработка Telegram сообщений
  - [`llm_client.py`](src/llm_client.py) - взаимодействие с Openrouter API
  - [`config.py`](src/config.py) - загрузка конфигурации

### Обработка сообщений
- **Прямая логика**: без middleware и сложных цепочек
- **Stateless**: каждый запрос обрабатывается независимо
- **Простая обработка ошибок**:

```python
async def handle_message(message: types.Message):
    try:
        response = await llm_client.get_response(message.text)
        await message.answer(response)
    except Exception as e:
        logger.error(f"Ошибка обработки сообщения: {e}")
        await message.answer("Извините, произошла ошибка")
```

### Конфигурация
- **`.env` файлы**: единственный источник конфигурации
- **Проверка обязательных переменных** при старте
- **Простая загрузка** без валидации сложных схем

## Качество кода

### Типизация
- **Type hints** для основных функций и публичного API
- **Минимальная типизация**: не переусердствовать с аннотациями

```python
def load_config() -> dict:
    """Загружает конфигурацию из переменных окружения."""
    return {
        "bot_token": os.getenv("TELEGRAM_BOT_TOKEN"),
        "api_key": os.getenv("OPENROUTER_API_KEY")
    }
```

### Обработка исключений
- **Ловите только ожидаемые исключения**
- **Логируйте ошибки** для отладки
- **Пользователю** - простые сообщения об ошибках

### Тестирование
- **Минимальное тестирование** только критической логики
- **Интеграционные тесты** важнее unit-тестов
- **Тестируйте основные сценарии** работы бота

## Принципы разработки

### KISS (Keep It Simple, Stupid)
- Каждая функция решает одну конкретную задачу
- Отсутствие сложных абстракций и наследования
- Прямая логика обработки сообщений

### YAGNI (You Aren't Gonna Need It)
- Нет базы данных (in-memory обработка)
- Нет системы аутентификации
- Нет сложной системы конфигурации
- Нет системы мониторинга на старте

### Минимализм
- **Минимальные зависимости**: только необходимые пакеты
- **Простой код**: понятный и читаемый
- **Быстрый старт**: простая настройка и развертывание

## Запрещенные практики

❌ Сложные паттерны проектирования  
❌ Избыточное наследование  
❌ Сложные системы middleware  
❌ Базы данных и ORM  
❌ Сложные системы валидации  
❌ Избыточное логгирование  
❌ Сложные системы промптов  
❌ Многопользовательские сессии  

## Рекомендуемые практики

✅ Прямая обработка сообщений  
✅ Простые функции с одной ответственностью  
✅ Ясные и понятные имена  
✅ Минимальное логгирование важных событий  
✅ Простая обработка ошибок  
✅ Stateless архитектура  
✅ Быстрая настройка и запуск